#!/usr/bin/env python3
"""
ðŸ§™â€â™‚ï¸ The Magical File Organizer CLI
Because typing SORT@Desktop is way cooler than a 50-character terminal command!

Usage:
    organize SORT@Desktop              # Sort Desktop by file type
    organize TAG@/path/to/folder       # AI tag all files in folder
    organize FIND@"invoice"            # Search for files
    organize CLEAN@Downloads           # Organize Downloads
    organize GRAPH@ProjectName         # Show project relationships
    organize SIMILAR@file.pdf          # Find similar files
    organize WHEN@"yesterday"          # Files from yesterday
    organize STATS                     # Show statistics
    organize EXPORT                    # Export to all formats
    organize HELP                      # This help

Shortcuts:
    organize @Desktop    = SORT@Desktop
    organize @Downloads  = SORT@Downloads
    organize ?invoice    = FIND@invoice
"""

import sys
import os
from datetime import datetime, timedelta

# Add current directory to path
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from file_indexer import FileDatabase, FileIndexer
from file_operations import FileOperations
from ai_tagger import AITagger
from vector_store import VectorSearchIntegration
from graph_store import FileGraphIntegration
from export_manager import ExportManager
from temporal_tracker import TemporalTracker
from setup_wizard import load_user_profile
from pathlib import Path

# NEW MODULES! ðŸŽ‰
from duplicate_detector import DuplicateDetector
from ocr_processor import OCRProcessor
from smart_folders import SmartFolders
from trash_manager import TrashManager
from reminder_system import ReminderSystem
from bulk_operations import BulkOperations
from aging_manager import AgingManager
from screenshot_manager import ScreenshotManager
from suggestions_engine import SuggestionsEngine
from bookmark_manager import BookmarkManager
from external_tools import ExternalToolIntegration
from mobile_companion import MobileCompanion
from performance_optimizer import PerformanceOptimizer


class MagicalCLI:
    """The quasi-cheesy but super useful CLI"""
    
    def __init__(self):
        self.db = FileDatabase()
        self.ops = FileOperations(self.db)
        self.temporal = TemporalTracker(self.db)
        self.profile = load_user_profile() or {}
        
        # Fun messages
        self.sparkles = "âœ¨"
        self.rocket = "ðŸš€"
        self.magic = "ðŸ§™â€â™‚ï¸"
        self.party = "ðŸŽ‰"
    
    def parse_command(self, arg):
        """Parse the cheesy command syntax"""
        arg = arg.strip()
        
        # Shortcuts
        if arg.startswith('@'):
            # @Desktop = SORT@Desktop
            return 'SORT', arg[1:]
        
        if arg.startswith('?'):
            # ?invoice = FIND@invoice
            return 'FIND', arg[1:].strip('"\'')
        
        if arg.startswith('!'):
            # !yesterday = WHEN@yesterday
            return 'WHEN', arg[1:].strip('"\'')
        
        # Full commands
        if '@' in arg:
            cmd, target = arg.split('@', 1)
            return cmd.upper(), target.strip('"\'')
        
        # Single word commands
        return arg.upper(), None
    
    def run(self, command_str):
        """Execute the magical command"""
        try:
            cmd, target = self.parse_command(command_str)
            
            if cmd == 'SORT' or cmd == 'CLEAN':
                return self.sort_folder(target)
            
            elif cmd == 'TAG':
                return self.tag_folder(target)
            
            elif cmd == 'FIND' or cmd == 'SEARCH':
                return self.find_files(target)
            
            elif cmd == 'GRAPH':
                return self.show_graph(target)
            
            elif cmd == 'SIMILAR':
                return self.find_similar(target)
            
            elif cmd == 'STATS':
                return self.show_stats()
            
            elif cmd == 'EXPORT':
                return self.export_index()
            
            elif cmd == 'WHEN' or cmd == 'TIME':
                return self.temporal_query(target)
            
            # NEW FEATURES! ðŸŽ‰
            elif cmd == 'DUPES' or cmd == 'DUPLICATES':
                return self.find_duplicates(target)
            
            elif cmd == 'OCR':
                return self.ocr_folder(target)
            
            elif cmd == 'SMART':
                return self.show_smart_folders(target)
            
            elif cmd == 'TRASH' or cmd == 'UNDELETE':
                return self.trash_operations(target)
            
            elif cmd == 'REMIND' or cmd == 'NUDGE':
                return self.show_reminders(target)
            
            elif cmd == 'BULK':
                return self.bulk_operations(target)
            
            elif cmd == 'AGING' or cmd == 'ARCHIVE':
                return self.aging_operations(target)
            
            elif cmd == 'SCREENSHOTS':
                return self.screenshot_operations(target)
            
            elif cmd == 'SUGGEST' or cmd == 'SUGGESTIONS':
                return self.show_suggestions()
            
            elif cmd == 'BOOKMARK' or cmd == 'BOOKMARKS':
                return self.bookmark_operations(target)
            
            elif cmd == 'OPTIMIZE' or cmd == 'OPTIMIZE':
                return self.optimize_database()
            
            elif cmd == 'HIDE' or cmd == 'UNHIDE':
                return self.hide_file_operations(target)
            
            elif cmd == 'MOBILE':
                return self.mobile_operations(target)
            
            elif cmd == 'ALFRED' or cmd == 'RAYCAST':
                return self.external_tool_setup(cmd)
            
            elif cmd == 'VIZ' or cmd == 'VISUALIZE':
                return self.show_visualizer(target)
            
            elif cmd == 'WATCH':
                return self.file_watcher_control(target)
            
            elif cmd == 'HIDE':
                return self.hide_file(target)
            
            elif cmd == 'HELP' or cmd == '--HELP' or cmd == '-H':
                return self.show_help()
            
            else:
                print(f"âŒ Unknown command: {cmd}")
                print(f"ðŸ’¡ Try: organize HELP")
                return 1
        
        except Exception as e:
            print(f"\nâŒ Oops! Something went wrong: {e}")
            print(f"ðŸ’¡ Try: organize HELP")
            return 1
        finally:
            self.db.close()
    
    def sort_folder(self, target):
        """SORT@folder - Organize files by type"""
        # Expand common names
        folder_map = {
            'Desktop': '~/Desktop',
            'Downloads': '~/Downloads',
            'Documents': '~/Documents',
            'Pictures': '~/Pictures'
        }
        
        folder = folder_map.get(target, target)
        folder = os.path.expanduser(folder)
        
        if not os.path.exists(folder):
            print(f"âŒ Folder not found: {folder}")
            return 1
        
        print(f"\n{self.magic} Sorting {Path(folder).name}...")
        print(f"   Organizing files by type...\n")
        
        results = self.ops.organize_by_type(folder)
        
        print(f"\n{self.party} Done!")
        print(f"   {self.sparkles} Moved: {results['moved']} files")
        print(f"   â­ï¸  Skipped: {results['skipped']} files")
        
        if results['errors']:
            print(f"   âš ï¸  Errors: {len(results['errors'])}")
        
        return 0
    
    def tag_folder(self, target):
        """TAG@folder - AI tag all files"""
        folder = os.path.expanduser(target)
        
        if not os.path.exists(folder):
            print(f"âŒ Folder not found: {folder}")
            return 1
        
        print(f"\n{self.magic} Tagging files in {Path(folder).name}...")
        
        # First, index the folder
        indexer = FileIndexer(self.db)
        indexed, skipped = indexer.scan_folder(folder, recursive=False)
        
        print(f"   ðŸ“ Indexed: {indexed} files")
        
        # Then tag with AI
        tagger = AITagger(user_profile=self.profile)
        tagged = tagger.tag_untagged_files(self.db, limit=50)
        
        print(f"\n{self.party} Done!")
        print(f"   {self.sparkles} Tagged: {tagged} files with AI")
        
        return 0
    
    def find_files(self, query):
        """FIND@query - Search for files"""
        if not query:
            print("âŒ Please provide a search query")
            print("ðŸ’¡ Example: organize FIND@invoice")
            return 1
        
        print(f"\nðŸ” Searching for: '{query}'...")
        
        results = self.db.search_files(query, limit=20)
        
        if not results:
            print(f"\nâŒ No files found matching '{query}'")
            print(f"ðŸ’¡ Try: organize TAG@folder (to index more files)")
            return 1
        
        print(f"\n{self.sparkles} Found {len(results)} files:\n")
        
        for i, r in enumerate(results[:10], 1):
            print(f"   {i}. {r['filename']}")
            if r['ai_summary']:
                print(f"      {r['ai_summary'][:60]}...")
            print(f"      ðŸ“ {Path(r['folder_location']).name}")
            print()
        
        if len(results) > 10:
            print(f"   ... and {len(results) - 10} more files")
        
        return 0
    
    def show_graph(self, project):
        """GRAPH@project - Show project relationships"""
        if not project:
            print("âŒ Please provide a project name")
            print("ðŸ’¡ Example: organize GRAPH@ClientX")
            return 1
        
        print(f"\nðŸ•¸ï¸  Analyzing relationships for '{project}'...\n")
        
        graph = FileGraphIntegration(self.db)
        graph.build_graph_from_database()
        
        files = graph.find_all_project_files(project)
        
        if not files:
            print(f"âŒ No files found for project '{project}'")
            return 1
        
        print(f"{self.sparkles} Found {len(files)} files:\n")
        
        for i, f in enumerate(files[:10], 1):
            print(f"   {i}. {f['filename']}")
            if f.get('summary'):
                print(f"      {f['summary'][:60]}...")
            print()
        
        if len(files) > 10:
            print(f"   ... and {len(files) - 10} more files")
        
        return 0
    
    def find_similar(self, target):
        """SIMILAR@file - Find similar files"""
        target = os.path.expanduser(target)
        
        if not os.path.exists(target):
            print(f"âŒ File not found: {target}")
            return 1
        
        print(f"\nðŸ” Finding files similar to {Path(target).name}...\n")
        
        vs = VectorSearchIntegration(self.db)
        similar = vs.find_related_files(target, top_k=5)
        
        if not similar:
            print(f"âŒ No similar files found")
            print(f"ðŸ’¡ Try: organize TAG@folder (to index more files)")
            return 1
        
        print(f"{self.sparkles} Similar files:\n")
        
        for i, f in enumerate(similar, 1):
            print(f"   {i}. {f['filename']} (similarity: {f['similarity']:.2f})")
            if f.get('ai_summary'):
                print(f"      {f['ai_summary'][:60]}...")
            print()
        
        return 0
    
    def show_stats(self):
        """STATS - Show database statistics"""
        stats = self.db.get_stats()
        
        print(f"\nðŸ“Š File Organizer Statistics\n")
        print(f"   ðŸ“ Total Files: {stats['total_files']}")
        print(f"   ðŸ“‚ Folders: {len(stats.get('by_folder', {}))}")
        print(f"   ðŸ“„ File Types: {len(stats.get('by_extension', {}))}")
        
        if stats.get('top_tags'):
            print(f"\n   ðŸ·ï¸  Top Tags:")
            for tag, count in list(stats['top_tags'].items())[:5]:
                print(f"      â€¢ {tag}: {count}")
        
        # Learned patterns
        patterns = self.db.get_learned_patterns(min_confidence=0.5)
        if patterns:
            print(f"\n   ðŸ§  Learned {len(patterns)} patterns")
        
        print()
        return 0
    
    def export_index(self):
        """EXPORT - Export file index"""
        print(f"\n{self.rocket} Exporting file index...\n")
        
        exporter = ExportManager(self.db)
        results = exporter.export_all_formats()
        
        print(f"\n{self.party} Exported to 4 formats!")
        print(f"\n   ðŸ“ Location: ~/.fileorganizer/exports/\n")
        
        for format_name, info in results.items():
            print(f"   â€¢ {format_name.upper()}: {Path(info['path']).name}")
        
        print(f"\nðŸ’¡ Open HTML: open ~/.fileorganizer/exports/*.html")
        print()
        
        return 0
    
    def temporal_query(self, query):
        """WHEN@query or !query - Temporal file queries"""
        if not query:
            print("âŒ Please provide a time expression")
            print("ðŸ’¡ Examples:")
            print("   organize !yesterday")
            print("   organize WHEN@'last week'")
            return 1
        
        print(f"\nâ° Searching for files from '{query}'...\n")
        
        results, start, end = self.temporal.query_files_by_time(query)
        
        if not results:
            print(f"âŒ No files found from that time period")
            return 1
        
        # Format time range
        time_desc = self._format_time_range(start, end)
        
        print(f"{self.sparkles} Found {len(results)} files from {time_desc}:\n")
        
        for i, item in enumerate(results[:15], 1):
            print(f"   {i}. {item['filename']}")
            print(f"      ðŸ“ {item['location']}")
            timestamp = item['timestamp'][:16].replace('T', ' ')
            print(f"      ðŸ• {timestamp}")
            if item.get('summary'):
                print(f"      ðŸ’¡ {item['summary'][:60]}...")
            print()
        
        if len(results) > 15:
            print(f"   ... and {len(results) - 15} more files")
        
        print()
        return 0
    
    def _format_time_range(self, start, end):
        """Format time range nicely"""
        now = datetime.now()
        
        if start.date() == end.date():
            if start.date() == now.date():
                return "today"
            elif start.date() == (now - timedelta(days=1)).date():
                return "yesterday"
            return start.strftime("%B %d")
        
        diff = (now - start).days
        if diff <= 7:
            return f"the last {diff} days"
        
        return f"{start.strftime('%b %d')} to {end.strftime('%b %d')}"
    
    def show_suggestions(self):
        """Show smart suggestions and nudges"""
        print(f"\nðŸ’¡ Smart Suggestions & Nudges\n")
        
        reminders = ReminderSystem(self.db)
        nudges = reminders.get_nudges(limit=10)
        
        if not nudges:
            print("âœ¨ All good! No suggestions at the moment.\n")
            return 0
        
        print(f"Found {len(nudges)} suggestions:\n")
        for i, nudge in enumerate(nudges, 1):
            priority_icon = "ðŸ”´" if nudge['priority'] >= 8 else "ðŸŸ " if nudge['priority'] >= 6 else "ðŸŸ¡"
            print(f"{i}. {priority_icon} {nudge['message']}")
            print(f"   Action: {nudge.get('action', 'review')}")
            print()
        
        return 0
    
    def show_reminders(self, target):
        """Show reminders"""
        print(f"\nâ° Reminders\n")
        
        reminder_sys = ReminderSystem(self.db)
        
        # Due reminders
        due = reminder_sys.get_due_reminders()
        if due:
            print(f"ðŸ”´ Due Now ({len(due)}):")
            for r in due[:5]:
                print(f"   â€¢ {r['filename']}: {r['message'] or 'Reminder'}")
            print()
        
        # Upcoming reminders
        upcoming = reminder_sys.get_upcoming_reminders(days_ahead=7)
        if upcoming:
            print(f"ðŸ“… Upcoming ({len(upcoming)}):")
            for r in upcoming[:5]:
                date = datetime.fromisoformat(r['reminder_date']).strftime('%m/%d')
                print(f"   â€¢ [{date}] {r['filename']}")
            print()
        
        if not due and not upcoming:
            print("âœ¨ No reminders set.\n")
        
        return 0
    
    def show_smart_folders(self, target):
        """Show smart folders"""
        print(f"\nðŸ“ Smart Folders\n")
        
        smart = SmartFolders(self.db)
        folders = smart.get_all_smart_folders()
        
        if not folders:
            print("No smart folders yet. Creating defaults...\n")
            created = smart.create_default_smart_folders()
            print(f"âœ… Created {len(created)} default folders\n")
            folders = smart.get_all_smart_folders()
        
        print(f"Found {len(folders)} smart folders:\n")
        for i, folder in enumerate(folders, 1):
            count = smart.get_file_count(folder['id'])
            print(f"{i}. {folder['icon']} {folder['name']}")
            print(f"   {count} files â€¢ {folder['description'] or 'No description'}")
            print()
        
        return 0
    
    def bookmark_operations(self, target):
        """Bookmark operations"""
        print(f"\nðŸ”– Bookmark Manager\n")
        
        manager = BookmarkManager(self.db)
        
        if not target:
            # Show all bookmarks
            bookmarks = manager.get_all_bookmarks(limit=20)
            print(f"ðŸ“š Your Bookmarks ({len(bookmarks)} total):\n")
            for i, bm in enumerate(bookmarks, 1):
                print(f"{i}. {bm['title']}")
                print(f"   {bm['url']}")
                if bm['tags']:
                    print(f"   Tags: {', '.join(bm['tags'])}")
                print()
        else:
            # Search bookmarks
            results = manager.search_bookmarks(query=target)
            print(f"ðŸ” Found {len(results)} bookmarks matching '{target}':\n")
            for i, bm in enumerate(results, 1):
                print(f"{i}. {bm['title']}")
                print(f"   {bm['url']}")
                print()
        
        return 0
    
    def optimize_database(self):
        """Optimize database performance"""
        print(f"\nâš¡ Optimizing Database...\n")
        
        optimizer = PerformanceOptimizer(self.db)
        optimizer.optimize_database()
        
        stats = optimizer.get_database_stats()
        print(f"\nðŸ“Š Database Stats:")
        print(f"   Size: {stats['db_size_mb']:.2f} MB")
        print(f"   Indexes: {stats['index_count']}")
        print(f"   Cache entries: {stats['search_cache_size']}")
        print()
        
        return 0
    
    def hide_file_operations(self, target):
        """Hide/unhide files from search"""
        if not target:
            print("Usage: organize HIDE@/path/to/file")
            return 1
        
        path = os.path.expanduser(target)
        cursor = self.db.conn.cursor()
        
        # Check current status
        cursor.execute("SELECT id, hide_from_app FROM files WHERE path = ?", (path,))
        row = cursor.fetchone()
        
        if not row:
            print(f"âŒ File not found: {path}")
            return 1
        
        file_id, hidden = row
        new_status = 0 if hidden else 1
        
        cursor.execute("UPDATE files SET hide_from_app = ? WHERE id = ?", (new_status, file_id))
        self.db.conn.commit()
        
        if new_status:
            print(f"ðŸ‘» Hidden from search: {os.path.basename(path)}")
        else:
            print(f"ðŸ‘ï¸  Visible in search: {os.path.basename(path)}")
        
        return 0
    
    def mobile_operations(self, target):
        """Mobile companion operations"""
        print(f"\nðŸ“± Mobile Companion\n")
        
        mobile = MobileCompanion(self.db)
        stats = mobile.get_mobile_stats()
        
        print(f"ðŸ“Š Stats:")
        print(f"   Total files: {stats['total_files']}")
        print(f"   Total size: {stats['total_size_mb']:.1f} MB")
        print(f"   Recent (7d): {stats['recent_files']}")
        
        if stats['top_types']:
            print(f"\nðŸ“„ Top file types:")
            for ext, count in list(stats['top_types'].items())[:5]:
                print(f"   {ext}: {count} files")
        
        print(f"\nðŸ’¡ Quick Suggestions:")
        suggestions = mobile.quick_organize_suggestion()
        for sug in suggestions:
            print(f"   [{sug['priority']}] {sug['message']}")
        
        print()
        return 0
    
    def external_tool_setup(self, tool):
        """Set up external tool integrations"""
        print(f"\nðŸ”§ Setting up {tool} Integration\n")
        
        tools = ExternalToolIntegration(self.db)
        
        if tool.upper() == 'ALFRED':
            output_dir = tools.generate_alfred_workflow()
            print(f"âœ… Alfred workflow created at:")
            print(f"   {output_dir}")
            print(f"\nTo install:")
            print(f"   1. Open Alfred Preferences")
            print(f"   2. Go to Workflows tab")
            print(f"   3. Import the workflow from above folder")
        
        elif tool.upper() == 'RAYCAST':
            output_dir = tools.generate_raycast_extension()
            print(f"âœ… Raycast extension created at:")
            print(f"   {output_dir}")
            print(f"\nTo install:")
            print(f"   1. Open Raycast")
            print(f"   2. Go to Extensions â†’ Add Extension")
            print(f"   3. Import from above folder")
        
        print()
        return 0
    
    def show_help(self):
        """Show help message"""
        help_text = f"""
{self.magic} The Magical File Organizer CLI {self.sparkles}

BASIC COMMANDS (The Cheesy Ones):
    
    organize SORT@Desktop          {self.sparkles} Sort Desktop by file type
    organize CLEAN@Downloads       {self.sparkles} Clean up Downloads folder
    organize TAG@/path/to/folder   {self.sparkles} AI tag all files in folder
    organize FIND@"invoice"        ðŸ” Search for files
    organize WHEN@"yesterday"      â° Files from yesterday
    organize GRAPH@ProjectName     ðŸ•¸ï¸  Show project relationships
    organize SIMILAR@file.pdf      ðŸ” Find similar files
    organize STATS                 ðŸ“Š Show statistics
    organize EXPORT                ðŸ“¤ Export file index

NEW FEATURES:
    
    organize SCREENSHOTS           ðŸ“¸ Manage screenshots
    organize DUPLICATES            ðŸ”„ Find duplicate files
    organize SMART                 ðŸ“ Show smart folders
    organize BOOKMARKS             ðŸ”– Manage bookmarks
    organize REMIND                â° Show reminders
    organize SUGGEST               ðŸ’¡ Get suggestions
    organize TRASH                 ðŸ—‘ï¸  View trash/recover files
    organize OPTIMIZE              âš¡ Optimize database
    organize HIDE@file             ðŸ‘» Hide file from search
    organize MOBILE                ðŸ“± Mobile companion stats
    organize ALFRED                ðŸ”® Setup Alfred integration
    organize RAYCAST               âš¡ Setup Raycast integration

SHORTCUTS (Even Cheesier!):
    
    organize @Desktop              = SORT@Desktop
    organize @Downloads            = SORT@Downloads
    organize ?invoice              = FIND@"invoice"
    organize !yesterday            = WHEN@"yesterday"

EXAMPLES:
    
    # Organize your desktop (the classic!)
    organize @Desktop
    
    # Find all invoices
    organize ?invoice
    
    # Tag files in Documents with AI
    organize TAG@Documents
    
    # Find files from yesterday
    organize WHEN@yesterday
    
    # Find files related to a project
    organize GRAPH@ClientX
    
    # Find files similar to one you have
    organize SIMILAR@~/Documents/proposal.pdf
    
    # Export everything to HTML catalog
    organize EXPORT

TIPS:
    
    â€¢ Use quotes for paths with spaces: organize TAG@"My Folder"
    â€¢ Common folders work without paths: Desktop, Downloads, Documents
    â€¢ The @ symbol is the magic - it separates command from target
    â€¢ ? is for quick searches, ! is for time searches

{self.rocket} Make it even easier - create an alias:
    echo 'alias o="organize"' >> ~/.zshrc
    
    Then just type: o @Desktop

"""
        print(help_text)
        return 0


def main():
    """Entry point"""
    
    # No arguments - show help
    if len(sys.argv) < 2:
        cli = MagicalCLI()
        cli.show_help()
        return 0
    
    # Get command
    command = ' '.join(sys.argv[1:])
    
    # Run it!
    cli = MagicalCLI()
    return cli.run(command)


if __name__ == "__main__":
    sys.exit(main())

